<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>EOL BSpline Library: BSplineBase&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>BSplineBase&lt; T &gt; Class Template Reference</h1><!-- doxytag: class="BSplineBase" -->
<p>The base class for a spline object containing the nodes for a given domain, cutoff wavelength, and boundary condition.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BSplineBase_8h_source.html">BSplineBase.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BSplineBase&lt; T &gt;:</div>
<div class="dynsection">
 <div class="center">
  <img src="classBSplineBase.gif" usemap="#BSplineBase&lt; T &gt;_map" alt=""/>
  <map id="BSplineBase&lt; T &gt;_map" name="BSplineBase&lt; T &gt;_map">
<area href="classBSpline.html" alt="BSpline&lt; T &gt;" shape="rect" coords="0,56,114,80"/>
</map>
 </div>
</div>

<p><a href="classBSplineBase-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a5e748cf066e66d178717673ec04400bb">BoundaryConditionTypes</a> { <a class="el" href="classBSplineBase.html#a5e748cf066e66d178717673ec04400bbab2cbe9b650cf1b47b98aeef19ddc81a0">BC_ZERO_ENDPOINTS</a> =  0, 
<a class="el" href="classBSplineBase.html#a5e748cf066e66d178717673ec04400bba73e5ec93ff720eff69ebc922e0adbf98">BC_ZERO_FIRST</a> =  1, 
<a class="el" href="classBSplineBase.html#a5e748cf066e66d178717673ec04400bbabe606d289277b3422eb8928803f55dbd">BC_ZERO_SECOND</a> =  2
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Boundary condition types. </p>
 <a href="classBSplineBase.html#a5e748cf066e66d178717673ec04400bb">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba4bbfe6bd296faa4751dcf73b90ccf0"></a><!-- doxytag: member="BSplineBase::datum_type" ref="aba4bbfe6bd296faa4751dcf73b90ccf0" args="" -->
typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><b>datum_type</b></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#ac7e23fd18ea3f194d179d6da62a59c6d">BSplineBase</a> (const T *x, int nx, double wl, int bc_type=BC_ZERO_SECOND, int num_nodes=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a spline domain for the given set of x values, cutoff wavelength, and boundary condition type.  <a href="#ac7e23fd18ea3f194d179d6da62a59c6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b1fdba9df8a3f0123f78ef4910a38f7"></a><!-- doxytag: member="BSplineBase::BSplineBase" ref="a1b1fdba9df8a3f0123f78ef4910a38f7" args="(const BSplineBase &amp;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a1b1fdba9df8a3f0123f78ef4910a38f7">BSplineBase</a> (const <a class="el" href="classBSplineBase.html">BSplineBase</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#acf18fd5d8fd0c0723fe8ef688a9d220f">setDomain</a> (const T *x, int nx, double wl, int bc_type=BC_ZERO_SECOND, int num_nodes=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the domain of this base.  <a href="#acf18fd5d8fd0c0723fe8ef688a9d220f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBSpline.html">BSpline</a>&lt; T &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a8b5cedde9516de8d3d70502b93377469">apply</a> (const T *y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="classBSpline.html" title="Used to evaluate a BSpline.">BSpline</a> smoothed curve for the given set of NX y values.  <a href="#a8b5cedde9516de8d3d70502b93377469"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#aa348e90f54e237276bf0947da927cd24">nodes</a> (int *nnodes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return array of the node coordinates.  <a href="#aa348e90f54e237276bf0947da927cd24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac749628a10c09afa9593c4315d9d1a75"></a><!-- doxytag: member="BSplineBase::nNodes" ref="ac749628a10c09afa9593c4315d9d1a75" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#ac749628a10c09afa9593c4315d9d1a75">nNodes</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of nodes (one more than the number of intervals). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b6a533b72487d286fe610882db05528"></a><!-- doxytag: member="BSplineBase::nX" ref="a7b6a533b72487d286fe610882db05528" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a7b6a533b72487d286fe610882db05528">nX</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of original x values. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f6f2b2080c68b79e40a40fafa44636c"></a><!-- doxytag: member="BSplineBase::Xmin" ref="a6f6f2b2080c68b79e40a40fafa44636c" args="()" -->
T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a6f6f2b2080c68b79e40a40fafa44636c">Xmin</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Minimum x value found. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3002c6ef83126236e1a2ff6a8995293"></a><!-- doxytag: member="BSplineBase::Xmax" ref="ad3002c6ef83126236e1a2ff6a8995293" args="()" -->
T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#ad3002c6ef83126236e1a2ff6a8995293">Xmax</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum x value found. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#abc3d3ee0e5cd4dc93758d25a6bd9f941">Alpha</a> (double wavelength)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the Alpha value for a given wavelength.  <a href="#abc3d3ee0e5cd4dc93758d25a6bd9f941"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cd4453e84abfc323fb1e9ce9bc47308"></a><!-- doxytag: member="BSplineBase::Alpha" ref="a2cd4453e84abfc323fb1e9ce9bc47308" args="()" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a2cd4453e84abfc323fb1e9ce9bc47308">Alpha</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return alpha currently in use by this domain. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#aa1cd42e86d06c2fcd56d422cca33ec54">ok</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the current state of the object, either ok or not ok.  <a href="#aa1cd42e86d06c2fcd56d422cca33ec54"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a694981dfca5154701a87319a79467de1"></a><!-- doxytag: member="BSplineBase::ImplVersion" ref="a694981dfca5154701a87319a79467de1" args="()" -->
static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a694981dfca5154701a87319a79467de1">ImplVersion</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a string describing the implementation version. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59777a705d51b304607a7dd7f95abe76"></a><!-- doxytag: member="BSplineBase::IfaceVersion" ref="a59777a705d51b304607a7dd7f95abe76" args="()" -->
static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a59777a705d51b304607a7dd7f95abe76">IfaceVersion</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a string describing the interface version. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a6219fc2b912a7fe31bcbb2f06dace4f8">Debug</a> (int on=-1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call this class method with a value greater than zero to enable debug messages, or with zero to disable messages.  <a href="#a6219fc2b912a7fe31bcbb2f06dace4f8"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a427b8861aed5102ac9a621211291ce1d"></a><!-- doxytag: member="BSplineBase::Base" ref="a427b8861aed5102ac9a621211291ce1d" args="" -->
typedef <a class="el" href="structBSplineBaseP.html">BSplineBaseP</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>Base</b></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8910fa43321182d1dbc192422f0d7518"></a><!-- doxytag: member="BSplineBase::Setup" ref="a8910fa43321182d1dbc192422f0d7518" args="(int num_nodes=0)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>Setup</b> (int num_nodes=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a487ad3598cbc9c75286e276ca13a8170"></a><!-- doxytag: member="BSplineBase::calculateQ" ref="a487ad3598cbc9c75286e276ca13a8170" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>calculateQ</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86ccf8bcfd237d1d2f663ee755c06c39"></a><!-- doxytag: member="BSplineBase::qDelta" ref="a86ccf8bcfd237d1d2f663ee755c06c39" args="(int m1, int m2)" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>qDelta</b> (int m1, int m2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ae444b1b403cf909503985d6e00cc1a"></a><!-- doxytag: member="BSplineBase::Beta" ref="a5ae444b1b403cf909503985d6e00cc1a" args="(int m)" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>Beta</b> (int m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07d41f0a26f4dd433f07b7a9bb73a7d9"></a><!-- doxytag: member="BSplineBase::addP" ref="a07d41f0a26f4dd433f07b7a9bb73a7d9" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>addP</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03fc1340f983afc5f1238183ae01f047"></a><!-- doxytag: member="BSplineBase::factor" ref="a03fc1340f983afc5f1238183ae01f047" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>factor</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5171903e7037da186a72eb636f7f537f"></a><!-- doxytag: member="BSplineBase::Basis" ref="a5171903e7037da186a72eb636f7f537f" args="(int m, T x)" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>Basis</b> (int m, T x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa64f1458530f4c64973f22425017fcc"></a><!-- doxytag: member="BSplineBase::DBasis" ref="aaa64f1458530f4c64973f22425017fcc" args="(int m, T x)" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>DBasis</b> (int m, T x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd6d8472188c5905a75da0a80770a3e4"></a><!-- doxytag: member="BSplineBase::Ratiod" ref="afd6d8472188c5905a75da0a80770a3e4" args="(int &amp;, double &amp;, double &amp;)" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>Ratiod</b> (int &amp;, double &amp;, double &amp;)</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6832f21d9950b7490e68958bd6ad5bf"></a><!-- doxytag: member="BSplineBase::waveLength" ref="ae6832f21d9950b7490e68958bd6ad5bf" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>waveLength</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66fd723695cc2bde8661cf46b153fe6d"></a><!-- doxytag: member="BSplineBase::NX" ref="a66fd723695cc2bde8661cf46b153fe6d" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>NX</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afccf27ca1d01311a750e110c116a2b11"></a><!-- doxytag: member="BSplineBase::K" ref="afccf27ca1d01311a750e110c116a2b11" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>K</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61c09cb70f97ea7d20f3c1c1d5d1a7a9"></a><!-- doxytag: member="BSplineBase::BC" ref="a61c09cb70f97ea7d20f3c1c1d5d1a7a9" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>BC</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f8307df0a8c77af9a170df6e3d84d79"></a><!-- doxytag: member="BSplineBase::xmax" ref="a8f8307df0a8c77af9a170df6e3d84d79" args="" -->
T&nbsp;</td><td class="memItemRight" valign="bottom"><b>xmax</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21657827a3d04f10bc91327257471a49"></a><!-- doxytag: member="BSplineBase::xmin" ref="a21657827a3d04f10bc91327257471a49" args="" -->
T&nbsp;</td><td class="memItemRight" valign="bottom"><b>xmin</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a514d1d6c3485a3bba14c7ca510a27b48"></a><!-- doxytag: member="BSplineBase::M" ref="a514d1d6c3485a3bba14c7ca510a27b48" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>M</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71a0519d5fa682418b2c7649d6d90202"></a><!-- doxytag: member="BSplineBase::DX" ref="a71a0519d5fa682418b2c7649d6d90202" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>DX</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ea8c9049ed48f8a8ac54adecd18bc8e"></a><!-- doxytag: member="BSplineBase::alpha" ref="a1ea8c9049ed48f8a8ac54adecd18bc8e" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>alpha</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3ccb2b06841f543d7312cdc564e02c3"></a><!-- doxytag: member="BSplineBase::OK" ref="af3ccb2b06841f543d7312cdc564e02c3" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>OK</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22fcb07641b369861bc924911464970c"></a><!-- doxytag: member="BSplineBase::base" ref="a22fcb07641b369861bc924911464970c" args="" -->
<a class="el" href="structBSplineBaseP.html">Base</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>base</b></td></tr>
<tr><td colspan="2"><h2>Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const double&nbsp;</td><td class="memItemRight" valign="bottom"><b>BoundaryConditions</b> [3][4]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ab1978db3ff075dcc92a003830bde99"></a><!-- doxytag: member="BSplineBase::PI" ref="a0ab1978db3ff075dcc92a003830bde99" args="" -->
static const double&nbsp;</td><td class="memItemRight" valign="bottom"><b>PI</b> = 3.1415927</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T&gt;<br/>
 class BSplineBase&lt; T &gt;</h3>

<p>The base class for a spline object containing the nodes for a given domain, cutoff wavelength, and boundary condition. </p>
<p>To smooth a single curve, the <a class="el" href="classBSpline.html" title="Used to evaluate a BSpline.">BSpline</a> interface contains a constructor which both sets up the domain and solves for the spline. Subsequent curves over the same domain can be created by <a class="el" href="classBSplineBase.html#a8b5cedde9516de8d3d70502b93377469" title="Create a BSpline smoothed curve for the given set of NX y values.">apply()</a>ing them to the <a class="el" href="classBSpline.html" title="Used to evaluate a BSpline.">BSpline</a> object, where <a class="el" href="classBSplineBase.html#a8b5cedde9516de8d3d70502b93377469" title="Create a BSpline smoothed curve for the given set of NX y values.">apply()</a> is a <a class="el" href="classBSplineBase.html" title="The base class for a spline object containing the nodes for a given domain, cutoff...">BSplineBase</a> method. [See <a class="el" href="classBSplineBase.html#a8b5cedde9516de8d3d70502b93377469" title="Create a BSpline smoothed curve for the given set of NX y values.">apply()</a>.] New curves can also be smoothed within the same <a class="el" href="classBSpline.html" title="Used to evaluate a BSpline.">BSpline</a> object by calling solve() with the new set of y values. [See <a class="el" href="classBSpline.html" title="Used to evaluate a BSpline.">BSpline</a>.] A <a class="el" href="classBSplineBase.html" title="The base class for a spline object containing the nodes for a given domain, cutoff...">BSplineBase</a> can be created on its own, in which case all of the computations dependent on the x values, boundary conditions, and cutoff wavelength have already been completed.</p>
<p>The solution of the cubic b-spline is divided into two parts. The first is the setup of the domain given the x values, boundary conditions, and wavelength. The second is the solution of the spline for a set of y values corresponding to the x values in the domain. The first part is done in the creation of the <a class="el" href="classBSplineBase.html" title="The base class for a spline object containing the nodes for a given domain, cutoff...">BSplineBase</a> object (or when calling the setDomain method). The second part is done when creating a <a class="el" href="classBSpline.html" title="Used to evaluate a BSpline.">BSpline</a> object (or calling solve() on a <a class="el" href="classBSpline.html" title="Used to evaluate a BSpline.">BSpline</a> object).</p>
<p>A <a class="el" href="classBSpline.html" title="Used to evaluate a BSpline.">BSpline</a> object can be created with either one of its constructors, or by calling <a class="el" href="classBSplineBase.html#a8b5cedde9516de8d3d70502b93377469" title="Create a BSpline smoothed curve for the given set of NX y values.">apply()</a> on an existing <a class="el" href="classBSplineBase.html" title="The base class for a spline object containing the nodes for a given domain, cutoff...">BSplineBase</a> object. Once a spline has been solved, it can be evaluated at any x value. The following example creates a spline curve and evaluates it over the domain:</p>
<div class="fragment"><pre class="fragment">

    vector&lt;float&gt; x;
    vector&lt;float&gt; y;
    { ... }
    int bc = BSplineBase&lt;float&gt;::BC_ZERO_SECOND;
    BSpline&lt;float&gt;::Debug = true;
    BSpline&lt;float&gt; spline (x.begin(), x.size(), y.begin(), wl, bc);
    if (spline.ok())
    {
        ostream_iterator&lt;float&gt; of(cout, "\t ");
        float xi = spline.Xmin();
    float xs = (spline.Xmax() - xi) / 2000.0;
    for (; xi &lt;= spline.Xmax(); xi += xs)
    {
        *of++ = spline.evaluate (xi);
    }
    }
 
</pre></div><p>In the usual usage, the <a class="el" href="classBSplineBase.html" title="The base class for a spline object containing the nodes for a given domain, cutoff...">BSplineBase</a> can compute a reasonable number of nodes for the spline, balancing between a few desirable factors. There needs to be at least 2 nodes per cutoff wavelength (preferably 4 or more) for the derivative constraint to reliably approximate a lo-pass filter. There should be at least 1 and preferably about 2 data points per node (measured just by their number and not by any check of the density of points across the domain). Lastly, of course, the fewer the nodes then the faster the computation of the spline. The computation of the number of nodes happens in the Setup() method during <a class="el" href="classBSplineBase.html" title="The base class for a spline object containing the nodes for a given domain, cutoff...">BSplineBase</a> construction and when <a class="el" href="classBSplineBase.html#acf18fd5d8fd0c0723fe8ef688a9d220f" title="Change the domain of this base.">setDomain()</a> is called. If the setup fails to find a desirable number of nodes, then the <a class="el" href="classBSplineBase.html" title="The base class for a spline object containing the nodes for a given domain, cutoff...">BSplineBase</a> object will return false from <a class="el" href="classBSplineBase.html#aa1cd42e86d06c2fcd56d422cca33ec54" title="Return the current state of the object, either ok or not ok.">ok()</a>.</p>
<p>The <a class="el" href="classBSplineBase.html#aa1cd42e86d06c2fcd56d422cca33ec54" title="Return the current state of the object, either ok or not ok.">ok()</a> method returns false when a <a class="el" href="classBSplineBase.html" title="The base class for a spline object containing the nodes for a given domain, cutoff...">BSplineBase</a> or <a class="el" href="classBSpline.html" title="Used to evaluate a BSpline.">BSpline</a> could not complete any operation successfully. In particular, as mentioned above, <a class="el" href="classBSplineBase.html#aa1cd42e86d06c2fcd56d422cca33ec54" title="Return the current state of the object, either ok or not ok.">ok()</a> will return false if some problem was detected with the domain values or if no reasonable number of nodes could be found for the given cutoff wavelength. Also, <a class="el" href="classBSplineBase.html#aa1cd42e86d06c2fcd56d422cca33ec54" title="Return the current state of the object, either ok or not ok.">ok()</a> on a <a class="el" href="classBSpline.html" title="Used to evaluate a BSpline.">BSpline</a> object will return false if the matrix equation could not be solved, such as after <a class="el" href="classBSpline.html" title="Used to evaluate a BSpline.">BSpline</a> construction or after a call to <a class="el" href="classBSplineBase.html#a8b5cedde9516de8d3d70502b93377469" title="Create a BSpline smoothed curve for the given set of NX y values.">apply()</a>.</p>
<p>If letting Setup() determine the number of nodes is not acceptable, the constructors and <a class="el" href="classBSplineBase.html#acf18fd5d8fd0c0723fe8ef688a9d220f" title="Change the domain of this base.">setDomain()</a> accept the parameter num_nodes. By default, num_nodes is passed as zero, forcing Setup() to calculate the number of nodes. However, if num_nodes is passed as 2 or greater, then Setup() will bypass its own algorithm and accept the given number of nodes instead. Obviously, it's up to the programmer to understand the affects of the number of nodes on the representation of the data and on the solution (or non-solution) of the spline. Remember to check the <a class="el" href="classBSplineBase.html#aa1cd42e86d06c2fcd56d422cca33ec54" title="Return the current state of the object, either ok or not ok.">ok()</a> method to detect when the spline solution has failed.</p>
<p>The interface for the <a class="el" href="classBSplineBase.html" title="The base class for a spline object containing the nodes for a given domain, cutoff...">BSplineBase</a> and <a class="el" href="classBSpline.html" title="Used to evaluate a BSpline.">BSpline</a> templates is defined in the header file <a class="el" href="BSpline_8h_source.html">BSpline.h</a>. The implementation is defined in <a class="el" href="BSpline_8cpp.html" title="This file defines the implementation for the BSpline and BSplineBase templates.">BSpline.cpp</a>. Source files which will instantiate the template should include the implementation file and <em>not</em> the interface. If the implementation for a specific type will be linked from elsewhere, such as a static library or Windows DLL, source files should only include the interface file. On Windows, applications should link with the import library BSpline.lib and make sure BSpline.dll is on the path. The DLL contains an implementation for BSpline&lt;float&gt; and BSpline&lt;double&gt;. For debugging, an application can include the implementation to get its own instantiation.</p>
<p>The algorithm is based on the cubic spline described by Katsuyuki Ooyama in Montly Weather Review, Vol 115, October 1987. This implementation has benefited from comparisons with a previous FORTRAN implementation by James L. Franklin, NOAA/Hurricane Research Division. In particular, the algorithm in the Setup() method is based mostly on his implementation (VICSETUP). The Setup() method finds a suitable default for the number of nodes given a domain and cutoff frequency. This implementation adopts most of the same constraints, including a constraint that the cutoff wavelength not be greater than the span of the domain values: wl &lt; max(x) - min(x). If this is not an acceptable constraint, then use the num_nodes parameter to specify the number of nodes explicitly.</p>
<p>The cubic b-spline is formulated as the sum of some multiple of the basis function centered at each node in the domain. The number of nodes is determined by the desired cutoff wavelength and a desirable number of x values per node. The basis function is continuous and differentiable up to the second degree. A derivative constraint is included in the solution to achieve the effect of a low-pass frequency filter with the given cutoff wavelength. The derivative constraint can be disabled by specifying a wavelength value of zero, which reduces the analysis to a least squares fit to a cubic b-spline. The domain nodes, boundary constraints, and wavelength determine a linear system of equations, Qa=b, where a is the vector of basis function coefficients at each node. The coefficient vector is solved by first LU factoring along the diagonally banded matrix Q in <a class="el" href="classBSplineBase.html" title="The base class for a spline object containing the nodes for a given domain, cutoff...">BSplineBase</a>. The <a class="el" href="classBSpline.html" title="Used to evaluate a BSpline.">BSpline</a> object then computes the B vector for a set of y values and solves for the coefficient vector with the LU matrix. Only the diagonal bands are stored in memory and calculated during LU factoring and back substitution, and the basis function is evaluated as few times as possible in computing the diagonal matrix and B vector.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Gary Granger (<a href="http://www.eol.ucar.edu/homes/granger">http://www.eol.ucar.edu/homes/granger</a>)</dd></dl>
<div class="fragment"><pre class="fragment">
Copyright (c) 1998-2009
University Corporation for Atmospheric Research, UCAR
All rights reserved.
</pre></div> <hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a5e748cf066e66d178717673ec04400bb"></a><!-- doxytag: member="BSplineBase::BoundaryConditionTypes" ref="a5e748cf066e66d178717673ec04400bb" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classBSplineBase.html#a5e748cf066e66d178717673ec04400bb">BSplineBase::BoundaryConditionTypes</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Boundary condition types. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a5e748cf066e66d178717673ec04400bbab2cbe9b650cf1b47b98aeef19ddc81a0"></a><!-- doxytag: member="BC_ZERO_ENDPOINTS" ref="a5e748cf066e66d178717673ec04400bbab2cbe9b650cf1b47b98aeef19ddc81a0" args="" -->BC_ZERO_ENDPOINTS</em>&nbsp;</td><td>
<p>Set the endpoints of the spline to zero. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5e748cf066e66d178717673ec04400bba73e5ec93ff720eff69ebc922e0adbf98"></a><!-- doxytag: member="BC_ZERO_FIRST" ref="a5e748cf066e66d178717673ec04400bba73e5ec93ff720eff69ebc922e0adbf98" args="" -->BC_ZERO_FIRST</em>&nbsp;</td><td>
<p>Set the first derivative of the spline to zero at the endpoints. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5e748cf066e66d178717673ec04400bbabe606d289277b3422eb8928803f55dbd"></a><!-- doxytag: member="BC_ZERO_SECOND" ref="a5e748cf066e66d178717673ec04400bbabe606d289277b3422eb8928803f55dbd" args="" -->BC_ZERO_SECOND</em>&nbsp;</td><td>
<p>Set the second derivative to zero. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac7e23fd18ea3f194d179d6da62a59c6d"></a><!-- doxytag: member="BSplineBase::BSplineBase" ref="ac7e23fd18ea3f194d179d6da62a59c6d" args="(const T *x, int nx, double wl, int bc_type=BC_ZERO_SECOND, int num_nodes=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::<a class="el" href="classBSplineBase.html">BSplineBase</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>wl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bc_type</em> = <code>BC_ZERO_SECOND</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_nodes</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a spline domain for the given set of x values, cutoff wavelength, and boundary condition type. </p>
<p>The parameters are the same as for <a class="el" href="classBSplineBase.html#acf18fd5d8fd0c0723fe8ef688a9d220f" title="Change the domain of this base.">setDomain()</a>. Call <a class="el" href="classBSplineBase.html#aa1cd42e86d06c2fcd56d422cca33ec54" title="Return the current state of the object, either ok or not ok.">ok()</a> to check whether domain setup succeeded after construction. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="abc3d3ee0e5cd4dc93758d25a6bd9f941"></a><!-- doxytag: member="BSplineBase::Alpha" ref="abc3d3ee0e5cd4dc93758d25a6bd9f941" args="(double wavelength)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::Alpha </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>wavelength</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the Alpha value for a given wavelength. </p>
<p>Note that this depends on the current node interval length (DX). </p>

</div>
</div>
<a class="anchor" id="a8b5cedde9516de8d3d70502b93377469"></a><!-- doxytag: member="BSplineBase::apply" ref="a8b5cedde9516de8d3d70502b93377469" args="(const T *y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBSpline.html">BSpline</a>&lt; T &gt; * <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a <a class="el" href="classBSpline.html" title="Used to evaluate a BSpline.">BSpline</a> smoothed curve for the given set of NX y values. </p>
<p>The returned object will need to be deleted by the caller. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The array of y values corresponding to each of the <a class="el" href="classBSplineBase.html#a7b6a533b72487d286fe610882db05528" title="Number of original x values.">nX()</a> x values in the domain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classBSplineBase.html#aa1cd42e86d06c2fcd56d422cca33ec54" title="Return the current state of the object, either ok or not ok.">ok()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6219fc2b912a7fe31bcbb2f06dace4f8"></a><!-- doxytag: member="BSplineBase::Debug" ref="a6219fc2b912a7fe31bcbb2f06dace4f8" args="(int on=&#45;1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::Debug </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>on</em> = <code>-1</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call this class method with a value greater than zero to enable debug messages, or with zero to disable messages. </p>
<p>Calling with no arguments returns true if debugging enabled, else false. </p>

</div>
</div>
<a class="anchor" id="aa348e90f54e237276bf0947da927cd24"></a><!-- doxytag: member="BSplineBase::nodes" ref="aa348e90f54e237276bf0947da927cd24" args="(int *nnodes)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::nodes </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>nnodes</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return array of the node coordinates. </p>
<p>Returns 0 if not <a class="el" href="classBSplineBase.html#aa1cd42e86d06c2fcd56d422cca33ec54" title="Return the current state of the object, either ok or not ok.">ok()</a>. The array of nodes returned by <a class="el" href="classBSplineBase.html#aa348e90f54e237276bf0947da927cd24" title="Return array of the node coordinates.">nodes()</a> belongs to the object and should not be deleted; it will also be invalid if the object is destroyed. </p>

</div>
</div>
<a class="anchor" id="aa1cd42e86d06c2fcd56d422cca33ec54"></a><!-- doxytag: member="BSplineBase::ok" ref="aa1cd42e86d06c2fcd56d422cca33ec54" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::ok </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the current state of the object, either ok or not ok. </p>
<p>Use this method to test for valid state after construction or after a call to <a class="el" href="classBSplineBase.html#acf18fd5d8fd0c0723fe8ef688a9d220f" title="Change the domain of this base.">setDomain()</a>. <a class="el" href="classBSplineBase.html#aa1cd42e86d06c2fcd56d422cca33ec54" title="Return the current state of the object, either ok or not ok.">ok()</a> will return false if either fail, such as when an appropriate number of nodes and node interval cannot be found for a given wavelength, or when the linear equation for the coefficients cannot be solved. </p>

</div>
</div>
<a class="anchor" id="acf18fd5d8fd0c0723fe8ef688a9d220f"></a><!-- doxytag: member="BSplineBase::setDomain" ref="acf18fd5d8fd0c0723fe8ef688a9d220f" args="(const T *x, int nx, double wl, int bc_type=BC_ZERO_SECOND, int num_nodes=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::setDomain </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>wl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bc_type</em> = <code>BC_ZERO_SECOND</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_nodes</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the domain of this base. </p>
<p>[If this is part of a <a class="el" href="classBSpline.html" title="Used to evaluate a BSpline.">BSpline</a> object, this method {<em>will</em> not} change the existing curve or re-apply the smoothing to any set of y values.]</p>
<p>The x values can be in any order, but they must be of sufficient density to support the requested cutoff wavelength. The setup of the domain may fail because of either inconsistency between the x density and the cutoff wavelength, or because the resulting matrix could not be factored. If setup fails, the method returns false.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The array of x values in the domain. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nx</em>&nbsp;</td><td>The number of values in the <code>x</code> array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wl</em>&nbsp;</td><td>The cutoff wavelength, in the same units as the <code>x</code> values. A wavelength of zero disables the derivative constraint. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bc_type</em>&nbsp;</td><td>The enumerated boundary condition type. If omitted it defaults to BC_ZERO_SECOND. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_nodes</em>&nbsp;</td><td>The number of nodes to use for the cubic b-spline. If less than 2 a reasonable number will be calculated automatically, if possible, taking into account the given cutoff wavelength.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classBSplineBase.html#aa1cd42e86d06c2fcd56d422cca33ec54" title="Return the current state of the object, either ok or not ok.">ok()</a>. </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a7857ee42bae59319f95a7baca5be814e"></a><!-- doxytag: member="BSplineBase::BoundaryConditions" ref="a7857ee42bae59319f95a7baca5be814e" args="[3][4]" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::BoundaryConditions<code> [inline, static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    {
            
                {
                        -4,
                        -1,
                        -1,
                        -4 },
                {
                        0,
                        1,
                        1,
                        0 },
                {
                        2,
                        -1,
                        -1,
                        2 } }
</pre></div>
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>BSpline/<a class="el" href="BSplineBase_8h_source.html">BSplineBase.h</a></li>
<li>BSpline/BSplineBase.cpp</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 1 Oct 2009 for EOL BSpline Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
